#!/bin/bash

# Be strict.  Write scripts accordingly.
set -u
set -o pipefail

CMD=${0##*/}

err () {
    {
        echo "*** ERROR ***"
        while (( $# > 0 )); do
            echo "$1"
            shift
        done
    } 1>&2
    exit 1
}

export STOP_ON_TEST_FAIL=0
export KEEP_KVDB=0
export VERBOSE=1

# set for each test
export TEST_SCRIPT_DIR=  # directory of test script
export TEST=             # name of test
export LOG_TOPDIR=       # all logs live under the top dir
export LOG_DIR=          # each test has its own log dir
export LOG=              # log file for current "cmd"


# local vars (not exported to scripts)
exported_functions=()
smoke_dir=$(readlink -m "${BASH_SOURCE[0]}"/..) || err "readlink"
smoke_test_dir=$smoke_dir/tests
build_dir=
mpool=


test_script_options=
test_list=()
test_args=()
show_test_names=1

exported_functions+=(err)

syntax () {
    {
        while (( $# > 0 )); do
            echo "$1"
            shift
        done
        echo "Use -h for help"
    } 1>&2
    exit 1
}

file_search () {
    local f=$1; shift
    local d

    for d in "$@"; do
        if [[ "$d" == "." || "$d" == "" ]]; then
            if [[ -f "$f" ]]; then
                echo "$f"
                return
            fi
        elif [[ -f "$d/$f" ]]; then
            echo "$d/$f"
            return
        fi
    done
}

get_tests () {
    ls "$smoke_test_dir" | grep -Pv '^(group|disabled)' | grep -v '~$'
}

get_group_tests () {
    echo "$1" | grep -q ^group || err "Invalid group: $1"
    [[ -f "$smoke_test_dir/$1" ]] || err "Invalid group: $1"
    sed -e 's/#.*//' "$smoke_test_dir/$1"
}

get_groups () {
    ls "$smoke_test_dir" | grep '^group' | grep -v '~$'
}

get_doc () {
    sed -nre 's/#doc:\s*//p' "$smoke_test_dir/$1" || err "Invalid test: $1"
}

get_test_script () {
    local t=$1; shift
    local search=("$smoke_test_dir" "$@")

    local f=$(file_search "$t" "${search[@]}")
    if [[ "$f" == "" ]]; then
        err "Invalid test: \"$t\"" \
            "Search path: ${search[@]}"
    fi
    echo "$f"
}

check_cli() {

    [[ -x "$HSE_CLI" ]] ||
        err "Cannot find HSE CLI in build tree: $HSE_CLI"

    "$HSE_CLI" -h &> /dev/null ||
        err "Cannot execute $HSE_CLI"
}

check_tools() {

    [[ -d "$HSE_TOOLS_DIR" ]] ||
        err "Cannot find tools dir in build tree: $HSE_TOOLS_DIR"

    local tool
    for tool in putbin kmt; do
        local f=$HSE_TOOLS_DIR/$tool
        [[ -x "$f" ]] ||
            err "Cannot find executable in tools dir: $f"
    done
}

check_tests () {
    local g
    local t
    # verify each test mentioned in a group is valid
    local GRPS=$(get_groups) || exit 1
    for g in $GRPS; do
        local GRPTESTS=$(get_group_tests "$g") || exit 1
        for t in $GRPTESTS; do
            (get_test_script "$t" >& /dev/null) ||
                err "Group $g contains a non-existent test: $t"
        done
    done
}

exported_functions+=(destroy_all_kvs)
destroy_all_kvs () {
    "$HSE_CLI" kvdb list -v "$mp" \
        | awk '($1=="kvslist:") {look=1} (look && $1 == "-") {print($2)}' \
        | while read name; do
        "$HSE_CLI" kvs destroy "$name" >/dev/null
    done
}

exported_functions+=(counter_reset)
counter_reset () {
    local f="$LOG_DIR/.counter.$1"
    echo 0 >> "$f"
}

exported_functions+=(counter_increment)
counter_increment () {
    local f="$LOG_DIR/.counter.$1"
    local count=$(cat "$f")
    (( count++ ))
    echo "$count" > "$f"
    echo "$count"
}

exported_functions+=(cmd)
cmd () {
    local more=1
    local check_status=1  # 0=ignore, 1=expect success, 2=expect error
    local check_signal=0
    local allow_stdout_noise=1
    local status
    while (( more && $# > 0 )); do
        case "$1" in
            (-i) # ignore status
                check_status=0;
                shift 1;;
            (--exp-err-status)  # expect error status
                check_status=2;
                shift 1;;
            (-s) # expect death by signal
                check_signal=$2
                check_signal=$((check_signal + 128))
                check_status=2;
                shift 2;;
            (-q) allow_stdout_noise=0; shift;;
            (-*) err "Unknown option: cmd $1";;
            (*)  more=0;;
        esac
    done

    local cmd_count=$(counter_increment cmd)
    local log_base=$LOG_DIR/cmd$(printf "%03d" $cmd_count)

    # This lets test scripts see logs from previous command
    LOG=$log_base.log
    LOG_ERR=$log_base.err

    echo "$@" > $log_base.cmd

    if (( allow_stdout_noise && VERBOSE > 1)); then
        # VERBOSE > 1 : user sees command line
        echo "#CMD: $@"
    fi
    if (( allow_stdout_noise && VERBOSE > 2 )); then
        # VERBOSE > 2 : user sees stdout/stderr
        "$@" 2>"$LOG_ERR" | tee "$LOG"
        cat "$LOG_ERR"
        status=${PIPESTATUS[0]}
    else
        "$@" >"$LOG" 2>"$LOG_ERR"
        status=$?
    fi

    echo "$status" > $log_base.status

    case "$check_status" in
        (0) ;; # ignore status
        (1) # expect success
            (( $status == 0 )) ||
                err "Command failed with status $status." \
                    "Command:  $*" \
                    "Log file: $LOG"
            ;;
        (*) # expect error status
            (( $status != 0 )) ||
                err "Expected command to fail, but it exited with status 0" \
                    "Command:  $*" \
                    "Log file: $LOG"
            ;;
    esac

    # Death by signal causes failure unless explicitly ignored.
    # special case: ignore 255 b/c many programs use exit(-1) which
    # maps to a return status of 255.
    if (( status >= 128 && status != 255 && status != check_signal )); then
        err "Command terminated by signal $((status-128))" \
            "Command: $*" \
            "Log file: $LOG"
    fi
    true
}

exported_functions+=(new_kvs)
new_kvs () {

    if (( $# < 1 )); then
	err "new_kvs takes mpool name as arg"
    fi

    local mp=$1 # TODO: use env var
    shift

    # reset counters
    local kvs_count=$(counter_increment kvs)
    local kvs_name=smoke$kvs_count
    cmd -q "$HSE_CLI" kvs create "$mp/$kvs_name" "$@"
    echo "$kvs_name"
}

run_one_test () {

    local script=$1
    TEST=${script##*/}
    TEST_SCRIPT_DIR=$(dirname $(readlink -m "$script"))

    LOG_DIR=$LOG_TOPDIR/$TEST

    # recreate LOG_DIR
    rm -f "$LOG_DIR"
    [[ -d "$LOG_DIR" ]] && err "Cannot remove old log directory: $LOG_DIR"
    mkdir -p "$LOG_DIR" || err "Cannot create log directory: $LOG_DIR"

    local test_argc=${#test_args[@]}

    # announce test
    if (( VERBOSE )); then
        echo ""
        if (( test_argc > 0 )); then
            echo "#TEST: $TEST" "${test_args[@]}"
        else
            echo "#TEST: $TEST"
        fi
        echo "#LOGS: $LOG_DIR/"
    fi

    # reset counters for test script
    counter_reset cmd
    counter_reset kvs

    # set env vars for test script
    export mp=$mpool

    case "$TEST" in
        (aloha|version) true;;
        (*) destroy_all_kvs;;
    esac

    start_sec=$(date +%s)
    start_nsec=$(date +%N)

    if (( test_argc > 0 )); then
        bash -u $test_script_options "$script" "${test_args[@]}"
        local test_failed=$?
    else
        bash -u $test_script_options "$script"
        local test_failed=$?
    fi

    if (( test_failed )); then
        touch $LOG_DIR/stat.failed
        if (( STOP_ON_TEST_FAIL )); then
            err "TEST FAILED"
        fi
    fi

    if (( ! KEEP_KVDB )); then
        destroy_all_kvs
    fi

    if (( ! test_failed )); then
        end_sec=$(date +%s)
        end_nsec=$(date +%N)

        # remove leading 0 from nsec values to ensure bash
        # seeds it as a base 10 number.

        start_nsec=$(echo "$start_nsec" | sed -e s/^0*//)
        [[ -z "$start_nsec" ]] && start_nsec=0

        end_nsec=$(echo "$end_nsec" | sed -e s/^0*//)
        [[ -z "$end_nsec" ]] && end_nsec=0

        (( msecs = (end_sec - start_sec) * 1000 + (end_nsec / 1000000 - start_nsec / 1000000) ))

        duration=$(printf "%d.%03d\n" $((msecs/1000)) $((msecs%1000)))

        if ((VERBOSE)); then
            echo "#TIME: $duration seconds"
        fi

        echo "$duration" > $LOG_DIR/duration
        touch $LOG_DIR/stat.success
    fi
}

show_groups () {
    local g
    for g in $(get_groups); do
        printf "%-20s    ## %s\n" "$g" "$(get_doc "$g")"
    done
}
show_tests () {
    local t
    for t in $(get_tests); do
        printf "%-20s  # %s\n" "$t" "$(get_doc "$t")"
    done
}
show_tests_long () {
    local g
    local t
    for g in $(get_groups); do
        printf "%-20s    ## %s\n" "$g" "$(get_doc "$g")"
        for t in $(get_group_tests "$g"); do
            printf "  %-20s  # %s\n" "$t" "$(get_doc "$t")"
        done
        printf "\n"
    done
}

help ()
{
    echo "Usage:"
    echo "  $CMD -C <BUILD_DIR> -m <mpool> [options]"
    echo "Required:"
    echo "  -C BUILD_DIR // set build dir (required)"
    echo "Options:"
    echo "  -d DIR       // override default log directory"
    echo "  -g           // list groups"
    echo "  -h           // show the help message"
    echo "  -l           // list tests"
    echo "  -L           // list tests, more detail"
    echo "  -s           // stop on first test failure"
    echo "  -v           // bump verbosity"
    echo "  -V N         // set verbosity (0=quiet, 2=max)"
    echo "  -x           // enable 'set -x' in test scripts (for debugging)"
    echo "Notes:"
    echo "  - Tests can be specified by name, by file or by group."
    echo "  - Some tests are broken.  They can be run by name or with group \"all\"".
    echo "Examples:"
    echo "  $CMD -C build -m mp1               # run standard smoke tests"
    echo "  $CMD -C build -m mp1 group.all     # run the 'all' group"
    echo "  $CMD -C build -m mp1 putget1 kmt1  # run specific tests"
    echo "  $CMD -C build -m mp1 tests/functional/smoke/tests/putget1   # run by file"
}


while getopts ":C:d:ghklLm:m:svV:x" option; do
    case "$option" in
        (C) build_dir=$OPTARG;;
        (d) LOG_TOPDIR=$OPTARG;;
        (g) show_groups; exit 0;;
        (h) help; exit 0;;
        (k) KEEP_KVDB=1;;
        (l) show_tests; exit 0;;
        (L) show_tests_long; exit 0;;
        (m) mpool=$OPTARG;;
        (s) STOP_ON_TEST_FAIL=1;;
        (v) (( VERBOSE++ ));;
        (V) (( VERBOSE=OPTARG )); [[ "$VERBOSE" =~ ^[0-9]+$ ]] || err "Invalid verbosity value: $OPTARG";;
        (x) test_script_options="-x";;
        (\?) err "Invalid option: -$OPTARG";;
        (:)  err "Invalid option: -$OPTARG requires a parameter";;
        (*)  err "Bug in option parsing!";;
    esac                      
done

shift $((OPTIND-1))
test_list=("$@")

[[ -n "$mpool"     ]] || err "Missing required parameter: -m <mpool>"
[[ -n "$build_dir" ]] || err "Missing required parameter: -C <build_dir>"
[[ -d "$build_dir" ]] || err "Non-existent build directory: $build_dir"

if [[ -z "$LOG_TOPDIR" ]]; then
    # Using default log dir
    LOG_TOPDIR=$build_dir/smokelogs
else
    # Not using default log dir: let user remove it to avoid rm -fr fiasco
    [[ ! -d "$LOG_TOPDIR" ]] ||
        err "Custom log directory already exists: $LOG_TOPDIR" \
            "Please remove it or use another path that doesn't yet exist"
fi

export HSE_SAMPLES_DIR=$build_dir/samples
export HSE_TOOLS_DIR=$build_dir/tools
export HSE_CLI=$build_dir/cli/hse1

check_cli
check_tools
check_tests

# Export shell functions to test scripts
for fn in "${exported_functions[@]}"; do
    export -f "$fn"
done

# stupid bash treats an empty array as an unset var, so turn off -u
# to check test_list, then re-enable
set +u
if (( "${#test_list[@]}" == 0 )); then
    test_list=(group.smoke)
fi
set -u

# convert test_list into script_list
script_list=()
for arg in "${test_list[@]}"; do

    match=0
    spath=()
    test_file=

    if [[ -f "$arg" || -h "$arg" ]]; then
        # path to test script given on command line
        test_file=$arg
        case "$arg" in
            (*/*)  spath=($(dirname $arg) $smoke_test_dir);;
            (*)    spath=($smoke_test_dir);;
        esac
    elif [[ -f "$smoke_test_dir/$arg" || -h "$smoke_test_dir/$arg" ]]; then
        # test scripts exists in standard smoke test dir
        test_file=$smoke_test_dir/$arg
        spath=($(dirname $arg))
    else
        err "No such test: $arg"
    fi

    if echo "$test_file" | grep -Pq '(^group|/group)\.\w+$'; then
        while read grptest; do
            script=$(get_test_script "$grptest" "${spath[@]}") || exit 1
            script_list+=($script)
        done < <(grep -Pv '(^#)|(^\s*$)' < "$test_file")
    else
        script_list+=($test_file)
    fi
done

# run tests
rm -fr "$LOG_TOPDIR"
mkdir -p "$LOG_TOPDIR"
for script in "${script_list[@]}"; do
    run_one_test "$script"
done

exit 0
